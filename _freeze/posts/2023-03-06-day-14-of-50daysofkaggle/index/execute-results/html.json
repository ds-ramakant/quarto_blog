{
  "hash": "c6c8f8e192ccb5d48545fb5787e76c9e",
  "result": {
    "markdown": "---\ntitle: \"Day 14 of #50daysofKaggle\"\nsubtitle: \"Roadmap to Tidymodels - Part 2\"\ndescription: \"Screening multiple models using workflows\"\ndate: '2023-03-20'\ncategories: [R, kaggle]\nfeatured: no\nexecute:\n  warning: false\nimage: Rplot.png\n---\n\n\nHow hard is it to evaluate multiple models when working on a given data problem?\n\nIf you're using the `tidymodels` package, the answer is surprisingly simple.\n\nToday's post is an attempt to use the `tidymodels` framework to screen multiple models. Inspiration for this post comes from the [Ch 15 of the Tidymodels with R textbook](https://www.tmwr.org/workflow-sets.html) along with two more noteworthy blogs\n\n-   [Olivier Gimenez's post](https://oliviergimenez.github.io/blog/learning-machine-learning/) that had me marvelling at the feature engineering\n-   [Tural Sadigov's post](https://rpubs.com/tsadigov/titanic_tidymodels) on handling multiple models\n\nI'm skipping the EDA component as I've covered it in the previous posts. Moving on to some boring (but very necessary) sections:\n\n# Loading the data\n\n`test` and `train` data is inputted and merged into a single dataframe\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(tidymodels)\n\n\ntitanic_train <- read.csv(\"train.csv\", header = T)\n\n#adding column to identify source\ntitanic_train <- titanic_train %>% \n  mutate(source = \"train\")\n\ntitanic_test <- read.csv(\"test.csv\", header = T)\n#adding column to identify source\ntitanic_test <- titanic_test %>% \n  mutate(Survived = NA,\n         source = \"test\")\n\n#merging the data. step1 starts here\ntitanic_data <- bind_rows(titanic_train, titanic_test)\n\nglimpse(titanic_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 1,309\nColumns: 13\n$ PassengerId <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17,â€¦\n$ Survived    <int> 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1â€¦\n$ Pclass      <int> 3, 1, 3, 1, 3, 3, 1, 3, 3, 2, 3, 1, 3, 3, 3, 2, 3, 2, 3, 3â€¦\n$ Name        <chr> \"Braund, Mr. Owen Harris\", \"Cumings, Mrs. John Bradley (Flâ€¦\n$ Sex         <chr> \"male\", \"female\", \"female\", \"female\", \"male\", \"male\", \"malâ€¦\n$ Age         <dbl> 22, 38, 26, 35, 35, NA, 54, 2, 27, 14, 4, 58, 20, 39, 14, â€¦\n$ SibSp       <int> 1, 1, 0, 1, 0, 0, 0, 3, 0, 1, 1, 0, 0, 1, 0, 0, 4, 0, 1, 0â€¦\n$ Parch       <int> 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 1, 0, 0, 5, 0, 0, 1, 0, 0, 0â€¦\n$ Ticket      <chr> \"A/5 21171\", \"PC 17599\", \"STON/O2. 3101282\", \"113803\", \"37â€¦\n$ Fare        <dbl> 7.2500, 71.2833, 7.9250, 53.1000, 8.0500, 8.4583, 51.8625,â€¦\n$ Cabin       <chr> \"\", \"C85\", \"\", \"C123\", \"\", \"\", \"E46\", \"\", \"\", \"\", \"G6\", \"Câ€¦\n$ Embarked    <chr> \"S\", \"C\", \"S\", \"S\", \"S\", \"Q\", \"S\", \"S\", \"S\", \"C\", \"S\", \"S\"â€¦\n$ source      <chr> \"train\", \"train\", \"train\", \"train\", \"train\", \"train\", \"traâ€¦\n```\n:::\n:::\n\n\n## Cleaning data\n\nChecking for `NA` values in the full df tells us that Age column has 86 missing in `test` & 177 missing values in `train` while there's 1 missing NA value in Fare. The 418 missing values in Survived in `test` are the ones we need to predict.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntitanic_data %>% \n  group_by(source) %>% \n  summarise_all(~ sum(is.na(.)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 Ã— 13\n  source Passeâ€¦Â¹ Surviâ€¦Â² Pclass  Name   Sex   Age SibSp Parch Ticket  Fare Cabin\n  <chr>    <int>   <int>  <int> <int> <int> <int> <int> <int>  <int> <int> <int>\n1 test         0     418      0     0     0    86     0     0      0     1     0\n2 train        0       0      0     0     0   177     0     0      0     0     0\n# â€¦ with 1 more variable: Embarked <int>, and abbreviated variable names\n#   Â¹â€‹PassengerId, Â²â€‹Survived\n```\n:::\n:::\n\n\n### Janitor::clean_names()\n\nNow i've got a thing about keeping column names clean so summoning `janitor` with a magic wand:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntitanic_data <- titanic_data %>% \n  mutate(family_count = SibSp+Parch+1) %>% \n  janitor::clean_names()\nnames(titanic_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"passenger_id\" \"survived\"     \"pclass\"       \"name\"         \"sex\"         \n [6] \"age\"          \"sib_sp\"       \"parch\"        \"ticket\"       \"fare\"        \n[11] \"cabin\"        \"embarked\"     \"source\"       \"family_count\"\n```\n:::\n:::\n\n\nVoila. Everything now in lower case and snake case!\n\n### Imputing NA values in `embarked`\n\nNow under **embarked** there are two rows that don't have `NA` but are blank. That's a bit oddðŸ¤¨\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntitanic_data %>% \n  count(embarked, sort = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  embarked   n\n1        S 914\n2        C 270\n3        Q 123\n4            2\n```\n:::\n:::\n\n\nSince it is only 2 such rows, I'll be replacing the `NA` values with the most repeated **embarked** value. So now zero empty values in **embarked**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmode_embarked <- titanic_data %>% \n  count(embarked, sort = T) %>% \n  select(embarked) %>% \n  head(1) %>% \n#this beautiful func comes from the purrr package. equivalent of .[[1]]\n  pluck(1)\n\ntitanic_data <- titanic_data %>% \n  mutate(embarked = if_else(embarked == \"\", mode_embarked, embarked))\n\ntitanic_data %>% \n  count(embarked, sort = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  embarked   n\n1        S 916\n2        C 270\n3        Q 123\n```\n:::\n:::\n\n\n### Imputing NA values in `age`\n\nThe **age** column has a bunch of missing values. My approach today is to substitute them with the median values when grouped by **sex** and **class**. Here's a function written to impute within the test and train data accordingly.\n\n*note: Feature engineering functions can be addressed in the `tidymodels`* *framework at recipe stage.*\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmedian_age_calc <- function(df){\n  median_ages <- df %>% \n    group_by(sex, pclass) %>% \n    summarise(age = median(age,na.rm = T))\n  df %>%\n    mutate(age = case_when((sex ==\"male\" & pclass ==1 & is.na(age)) ~ median_ages$age[1],\n                           (sex ==\"male\" & pclass ==2 & is.na(age)) ~ median_ages$age[2],\n                           (sex ==\"male\" & pclass ==3 & is.na(age)) ~ median_ages$age[3],\n                           (sex ==\"female\" & pclass ==1 & is.na(age)) ~ median_ages$age[4],\n                           (sex ==\"female\" & pclass ==2 & is.na(age)) ~ median_ages$age[5],\n                           (sex ==\"female\" & pclass ==3 & is.na(age)) ~ median_ages$age[6],\n                           .default = age)\n    )\n}\n\ntitanic_data <- titanic_data %>% \n  median_age_calc() %>% ungroup()\n```\n:::\n\n\nAre there any `na` values in the titanic data now?\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntitanic_data %>% \n  select(source, survived, sex, pclass, fare, age) %>% \n  group_by(source) %>% \n  summarise_all(~ sum(is.na(.)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 Ã— 6\n  source survived   sex pclass  fare   age\n  <chr>     <int> <int>  <int> <int> <int>\n1 test        418     0      0     1     0\n2 train         0     0      0     0     0\n```\n:::\n:::\n\n\nPhew. So age is covered. What are the median values now?\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntitanic_data %>% \n  group_by(pclass, sex) %>%\n  summarise(median_age = median(age))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 Ã— 3\n# Groups:   pclass [3]\n  pclass sex    median_age\n   <int> <chr>       <dbl>\n1      1 female       37.5\n2      1 male         37  \n3      2 female       28  \n4      2 male         28  \n5      3 female       25  \n6      3 male         22  \n```\n:::\n:::\n\n\n### Imputing `NA` values for fare\n\nThere's this one person (passenger_id = 1044, male and pclass = 3) who has a `na` value in **fare** from `test` data. Replacing it with the median value.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntitanic_data %>% \n  select(source, name, passenger_id, sex, age, pclass, fare) %>% \n  filter(is.na(fare))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  source               name passenger_id  sex  age pclass fare\n1   test Storey, Mr. Thomas         1044 male 60.5      3   NA\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntitanic_data %>% \n  group_by(sex, pclass) %>% \n  summarise(median_fare = median(fare, na.rm = T))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 Ã— 3\n# Groups:   sex [2]\n  sex    pclass median_fare\n  <chr>   <int>       <dbl>\n1 female      1       80.9 \n2 female      2       23   \n3 female      3       10.5 \n4 male        1       49.5 \n5 male        2       13   \n6 male        3        7.90\n```\n:::\n:::\n\n\nReplacing in the main df\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntitanic_data <- titanic_data %>% \n  mutate(fare = if_else(is.na(fare), \n#from the above table. Urgh!! hard coding for that 1 guy!! how inelegant.\n                        7.8958, age))\n```\n:::\n\n\n# Feature Engineering\n\nFor this post, I've focussed on a different approach while predicting survival probabilities. The guiding principle here is to club passengers from the same family and/or the same ticket_ID. The `titanic` dataset poses the challenge of having people within the same family purchase different tickets while at the same time so **surnames** really are not always the best grouping feature.\n\nOne such example is the Cacic family:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntitanic_data %>% \n  select(name, sex,age, ticket, survived) %>% \n  filter(str_detect(name, \"Cacic\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                  name    sex age ticket survived\n1      Cacic, Mr. Luka   male  38 315089        0\n2  Cacic, Miss. Marija female  30 315084        0\n3   Cacic, Miss. Manda female  21 315087       NA\n4 Cacic, Mr. Jego Grga   male  18 315091       NA\n```\n:::\n:::\n\n\nHow about only clubbing with only **surname**? Well, that also gets tricky because sometimes we have instances of people within the same **ticket** sharing multiple **surnames.**\n\nCase in point is ticket 1601:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntitanic_data %>% \n  select(name, sex, age, ticket, survived) %>% \n  filter(ticket==1601)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n             name  sex age ticket survived\n1   Bing, Mr. Lee male  32   1601        1\n2   Ling, Mr. Lee male  28   1601        0\n3  Lang, Mr. Fang male  26   1601        1\n4 Foo, Mr. Choong male  22   1601        1\n5    Lam, Mr. Ali male  22   1601        1\n6    Lam, Mr. Len male  22   1601        0\n7 Chip, Mr. Chang male  32   1601        1\n8   Hee, Mr. Ling male  22   1601       NA\n```\n:::\n:::\n\n\nIn times of crisis, it is expected that groups that traveled together will look out for their own. While this is not a thumb rule, I wanted to create a custom column that will combine the **ticket** and **surnames**.\n\nSo first step is to finding the surnames. That means using regex. Lovely ðŸ¤¢\n\n## Splitting names\n\nWith absolutely no guilt, I confess that this took me almost an entire day to figure out. And am I glad to have done it. The best thing about the tidyverse approach is the onus on making readable data. For that I'm grateful to discover functions like `seperate_wider_regex`.\n\nEssentially, it is a delimiter that breaks up columns based on the string patterns. So neat!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames_with_splchar <- regex(\"[A-Za-z]+[\\\\'\\\\-\\\\s]+[A-Za-z]+\")\nnames_with_3words <- regex(\"[A-Za-z]+\\\\s[A-Za-z]+\\\\s[A-Za-z]+\")\nnames_with_1word <- regex(\"[A-Za-z]+\") \nnames_with_2words <- regex(\"[A-Za-z]+\\\\s+[A-Za-z]+\")\n\n\ntitanic_data <- titanic_data %>% \n  separate_wider_regex(\n    name, \n    patterns = c(\n#IMP: ordering of regex patterns changes the outcome\n      surname = str_c(c(names_with_splchar, \n                        names_with_3words,\n                        names_with_1word), \n                      collapse = \"|\"),    # picks the first word before comma\n      \", \",                               # the comma  \n#IMP: ordering of regex patterns changes the outcome\n      title = str_c(c(names_with_2words , # two words with special char in between like 'the countess'\n                      names_with_1word),  # one word such as Mr Miss Mrs etc\n                    collapse = \"|\"),      \n      \". \",                               # the dot\n      given_name = \".+\"),                 # picks anything else which occurs at least once\n    cols_remove = F                       # retains the original column    \n  ) \n\ntitanic_data %>% \n  select(name, title, surname, given_name) %>% \n  head(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 Ã— 4\n   name                                                title  surname   given_â€¦Â¹\n   <chr>                                               <chr>  <chr>     <chr>   \n 1 Braund, Mr. Owen Harris                             Mr     Braund    Owen Haâ€¦\n 2 Cumings, Mrs. John Bradley (Florence Briggs Thayer) Mrs    Cumings   John Brâ€¦\n 3 Heikkinen, Miss. Laina                              Miss   Heikkinen Laina   \n 4 Futrelle, Mrs. Jacques Heath (Lily May Peel)        Mrs    Futrelle  Jacquesâ€¦\n 5 Allen, Mr. William Henry                            Mr     Allen     Williamâ€¦\n 6 Moran, Mr. James                                    Mr     Moran     James   \n 7 McCarthy, Mr. Timothy J                             Mr     McCarthy  Timothyâ€¦\n 8 Palsson, Master. Gosta Leonard                      Master Palsson   Gosta Lâ€¦\n 9 Johnson, Mrs. Oscar W (Elisabeth Vilhelmina Berg)   Mrs    Johnson   Oscar Wâ€¦\n10 Nasser, Mrs. Nicholas (Adele Achem)                 Mrs    Nasser    Nicholaâ€¦\n# â€¦ with abbreviated variable name Â¹â€‹given_name\n```\n:::\n:::\n\n\nWhat is the break of titles now?\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntitanic_data %>% \n  count(title, sort= T)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 18 Ã— 2\n   title            n\n   <chr>        <int>\n 1 Mr             757\n 2 Miss           260\n 3 Mrs            197\n 4 Master          61\n 5 Dr               8\n 6 Rev              8\n 7 Col              4\n 8 Major            2\n 9 Mlle             2\n10 Ms               2\n11 Capt             1\n12 Don              1\n13 Dona             1\n14 Jonkheer         1\n15 Lady             1\n16 Mme              1\n17 Sir              1\n18 the Countess     1\n```\n:::\n:::\n\n\n## Creating a custom grouping\n\nThe **ticket** is going to be broken up into **ticket_tail** (the last character) and **ticket_head** (all but the last character). Then we merge **surname** and **ticket_head** to create a **group_id**\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntitanic_data <- titanic_data %>% \n  mutate(ticket_head = substr(ticket, 1, nchar(ticket)-1),\n         ticket_tail = substr(ticket, nchar(ticket), nchar(ticket)),\n         group_id = paste0(surname, \"_\", ticket_head)) \n```\n:::\n\n\nCreating columns that indicate the number of people and other flags\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntitanic_data <- titanic_data %>% \n  add_count(group_id) %>% rename(pax_in_group = n)\n\ntitanic_data <- titanic_data %>% \n  mutate(flag = case_when ((family_count==1 & pax_in_group==1) ~ \"1_solo\",\n                           family_count == pax_in_group ~ \"2_family_full\",\n                           !(family_count == pax_in_group) ~ \"3_clubbed\",\n                           .default = \"x\"))\n\ntitanic_data <- titanic_data %>% \n  add_count(ticket_head) %>% \n  rename(pax_in_ticket_head = n)\n\n# how many instances of the same ticket having multiple groups? \ntitanic_data <- titanic_data %>% \n  group_by(ticket) %>% \n  mutate(groups_in_ticket = n_distinct(group_id)) %>% ungroup()\n\n# which tickets that have more than 1 groups in them? \n#     these passengers will have ticket_grouping precedence as they may include \n#     nannies, relatives & friends that don't share the same surname\nticket_with_multiple_groups <- titanic_data %>% \n  filter(!groups_in_ticket==1) %>% \n  count(ticket, sort = T)\n\ntitanic_data <- titanic_data %>% \n  mutate(final_grouping = if_else(ticket %in% ticket_with_multiple_groups$ticket, \n                             ticket, group_id),\n         final_label = if_else(ticket %in% ticket_with_multiple_groups$ticket,\n                         \"4_ticket_grouping\", flag)) \n```\n:::\n\n\nSince the code now has become a bit too long and I'm creating a checkpost here with a new df called `titanic_data2`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntitanic_data2 <- titanic_data %>% \n  select(source, passenger_id, survived,  sex, age, fare, pclass, embarked, \n         family_count, pax_in_group, pax_in_ticket_head, groups_in_ticket,\n         final_grouping) %>% \n  mutate(final_grouping = as_factor(final_grouping),\n         survived = as_factor(survived),\n         pclass = as_factor(pclass),\n         sex = as_factor(sex),\n         embarked = as_factor(embarked))\nglimpse(titanic_data2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 1,309\nColumns: 13\n$ source             <chr> \"train\", \"train\", \"train\", \"train\", \"train\", \"trainâ€¦\n$ passenger_id       <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, â€¦\n$ survived           <fct> 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, â€¦\n$ sex                <fct> male, female, female, female, male, male, male, malâ€¦\n$ age                <dbl> 22, 38, 26, 35, 35, 22, 54, 2, 27, 14, 4, 58, 20, 3â€¦\n$ fare               <dbl> 22, 38, 26, 35, 35, 22, 54, 2, 27, 14, 4, 58, 20, 3â€¦\n$ pclass             <fct> 3, 1, 3, 1, 3, 3, 1, 3, 3, 2, 3, 1, 3, 3, 3, 2, 3, â€¦\n$ embarked           <fct> S, C, S, S, S, Q, S, S, S, C, S, S, S, S, S, S, Q, â€¦\n$ family_count       <dbl> 2, 2, 1, 2, 1, 1, 1, 5, 3, 2, 3, 1, 1, 7, 1, 1, 6, â€¦\n$ pax_in_group       <int> 1, 2, 1, 2, 1, 1, 1, 5, 3, 2, 3, 1, 1, 7, 1, 1, 6, â€¦\n$ pax_in_ticket_head <int> 5, 14, 2, 8, 1, 1, 6, 5, 4, 4, 3, 14, 1, 22, 8, 1, â€¦\n$ groups_in_ticket   <int> 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, â€¦\n$ final_grouping     <fct> Braund_A/5 2117, Cumings_PC 1759, Heikkinen_STON/O2â€¦\n```\n:::\n:::\n\n\nNow this is the part I don't get. Why does Kaggle call it `train` and `test` when it can be easily told to be `given_data` and `to_predict` data?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nto_predict <- titanic_data2 %>% \n  filter(source == \"test\") %>% select(-survived, -source)\ngiven_data <- titanic_data2 %>% \n  filter(source == \"train\") %>% select(-source)\n```\n:::\n\n\n`given_data` has all the necessary columns we need to train the algo on\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(given_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 891\nColumns: 12\n$ passenger_id       <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, â€¦\n$ survived           <fct> 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, â€¦\n$ sex                <fct> male, female, female, female, male, male, male, malâ€¦\n$ age                <dbl> 22, 38, 26, 35, 35, 22, 54, 2, 27, 14, 4, 58, 20, 3â€¦\n$ fare               <dbl> 22, 38, 26, 35, 35, 22, 54, 2, 27, 14, 4, 58, 20, 3â€¦\n$ pclass             <fct> 3, 1, 3, 1, 3, 3, 1, 3, 3, 2, 3, 1, 3, 3, 3, 2, 3, â€¦\n$ embarked           <fct> S, C, S, S, S, Q, S, S, S, C, S, S, S, S, S, S, Q, â€¦\n$ family_count       <dbl> 2, 2, 1, 2, 1, 1, 1, 5, 3, 2, 3, 1, 1, 7, 1, 1, 6, â€¦\n$ pax_in_group       <int> 1, 2, 1, 2, 1, 1, 1, 5, 3, 2, 3, 1, 1, 7, 1, 1, 6, â€¦\n$ pax_in_ticket_head <int> 5, 14, 2, 8, 1, 1, 6, 5, 4, 4, 3, 14, 1, 22, 8, 1, â€¦\n$ groups_in_ticket   <int> 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, â€¦\n$ final_grouping     <fct> Braund_A/5 2117, Cumings_PC 1759, Heikkinen_STON/O2â€¦\n```\n:::\n:::\n\n\n`to_predict` dataframe has everything else except **survived** column that needs to be predicted.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(to_predict)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 418\nColumns: 11\n$ passenger_id       <int> 892, 893, 894, 895, 896, 897, 898, 899, 900, 901, 9â€¦\n$ sex                <fct> male, female, male, male, female, male, female, malâ€¦\n$ age                <dbl> 34.5, 47.0, 62.0, 27.0, 22.0, 14.0, 30.0, 26.0, 18.â€¦\n$ fare               <dbl> 34.5, 47.0, 62.0, 27.0, 22.0, 14.0, 30.0, 26.0, 18.â€¦\n$ pclass             <fct> 3, 3, 2, 3, 3, 3, 3, 2, 3, 3, 3, 1, 1, 2, 1, 2, 2, â€¦\n$ embarked           <fct> Q, S, Q, S, S, S, Q, S, C, S, S, S, S, S, S, C, Q, â€¦\n$ family_count       <dbl> 1, 2, 1, 1, 3, 1, 1, 3, 1, 3, 1, 1, 2, 2, 2, 2, 1, â€¦\n$ pax_in_group       <int> 1, 1, 1, 1, 2, 1, 1, 3, 1, 3, 1, 1, 2, 2, 2, 2, 1, â€¦\n$ pax_in_ticket_head <int> 3, 1, 1, 6, 11, 3, 3, 6, 16, 4, 10, 3, 2, 2, 2, 4, â€¦\n$ groups_in_ticket   <int> 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, â€¦\n$ final_grouping     <fct> Kelly_33091, Wilkes_36327, Myles_24027, Wirz_31515,â€¦\n```\n:::\n:::\n\n\nPhew. finally done with the pre-processing. Thanks for sticking around. Here have a gif\n\n![](https://media.giphy.com/media/lSVXGiITXtabGGxAyg/giphy.gif){fig-align=\"center\" width=\"240\"}\n\n# Model Building \n\nSo today I'm going to be taking different classification models and compare the findings on a 10-fold bootstrap resample. The 4 selected models are:\n\n1.  Logistic classification\n2.  Random Forest\n3.  Support Vector Machines\n4.  Decision Trees\n\nThe [Tidymodels textbook](https://www.tmwr.org/workflows.html#workflow-sets-intro) is possibly the best place to begin understanding about workflow. In a nutshell:\n\n-   Create resampling folds\n\n-   Describe each model (I'm going to be using untuned parameters for sake of simplicity)\n\n-   create a recipe for each model\n\n-   Just as you would with a single model, the workflow combines the base recipe with the multiple models but it takes the form of a list here\n\n-   Fit the resampled folds on the workflow_set\n\n-   Find the winning model - since we're dealing with classification, I am using `roc_auc`\n\n-   fit the winning model to the `given data`\n\n-   Generate predictions on `to_predict` df using the best fit\n\n-   submit on kaggle\n\n-   ...\n\n-   profit? (well not exactly. but you can create another blog and share your new found knowledge with the worldðŸ¤“)\n\nSo lets get cooking!\n\n## The Recipe \n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}